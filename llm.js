/**
 * @license
 * Copyright Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
// @ts-check

import {parse} from './jsonriver.js';

// console.log(
//   await fetch(
//     'https://openrouter.ai/api/v1/parameters/google/gemini-flash-1.5-8b',
//   ),
// );

export async function* makeLlmRequest(request, abortSignal = undefined) {
  const response = await fetch(
    'https://openrouter.ai/api/v1/chat/completions',
    {
      method: 'POST',
      signal: abortSignal,
      headers: {
        // If you're reading this, you're definitely smart enough to figure out
        // how to get this key.
        // It's only got a few bucks in it, enough for anyone who wants to
        // play a bit with using jsonriver to parse JSON.
        // I trust you not to be a jerk :)
        Authorization: `Bearer ${decode(
          '\u001f\u0007@A\u0018^\u001a]@\u0019\bG\tT\u000e\u0017]@\bZ\\KZG\u000f\b\b\u001bRD\u000e[T\u001dZ\u0016^T[\u001fR@Y\t]\u0017\tJ\r\b\f\u0019YJ]_T\u001cR\u0011\\\t\tO\u000eF\rY^\u001e\u000eK\n',
        )}`,
        'HTTP-Referer': 'https://github.com/rictic/jsonriver',
        'X-Title': `jsonriver examples`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'openai/gpt-4o',
        stream: true,
        messages: [
          {
            role: 'user',
            content:
              'Please call the get_latest_population_count function to get the population of the top fifty countries by gdp.',
          },
        ],
        tools: [
          {
            type: 'function',
            function: {
              name: 'get_latest_population_count',
              parameters: {
                type: 'object',
                properties: {
                  polities: {
                    type: 'array',
                    items: {
                      type: 'string',
                    },
                  },
                },
                required: ['name'],
                additionalProperties: false,
              },
            },
          },
        ],
      }),
    },
  );
  if (!response.ok) {
    throw new Error(`Failed to make request: ${response.status}`);
  }
  // The response comes down as SSE events that each have a JSON payload which
  // itself contains a bit of text generated by the model which we then
  // want to pass to jsonriver to parse!
  yield* parse(stripWrappers(getLlmOutput(response)));
}

/**
 * @param {AsyncIterableIterator<Choice>} choices
 */
async function* buildOutput(choices) {
  const result = {
    responseText: '',
    toolCallse: []
  }
  for await (const choice of choices) {

  }
}



async function* stripWrappers(stream) {
  // Some models wrap their output in a ```json\n...\n``` block, which we want
  // to strip off.
  let buffer = '';
  while (true) {
    const chunk = await stream.next();
    if (chunk.done) {
      break;
    }
    buffer += chunk.value;
    if (buffer.startsWith('```json')) {
      buffer = buffer.slice('```json\n'.length);
      break;
    } else if (buffer.length > 20) {
      break;
    }
  }
  // Now we just pass through the rest of the stream, but delayed by
  // eight characters so that when we're finished we can strip off the
  // trailing ```
  while (true) {
    const chunk = await stream.next();
    if (chunk.done) {
      break;
    }
    buffer += chunk.value;
    if (buffer.length > 8) {
      yield buffer.slice(0, -8);
      buffer = buffer.slice(-8);
    }
  }
  const match = buffer.match(/```\s+$/m);
  if (match) {
    yield buffer.slice(0, match.index);
  } else {
    yield buffer;
  }
}

/**
 * @param {Response} response
 * @returns {AsyncGenerator<Choice>}
 */
async function* getLlmOutput(response) {
  packets: for await (const event of packetizeSSE(response)) {
    const parsed = parseServerSentEvent(event);
    for (const part of parsed.parts) {
      if (part.type === 'field' && part.name === 'data') {
        if (part.value === '[DONE]') {
          break packets;
        }
        let parsed;
        try {
          parsed = /** @type {StreamedResponse} */ (JSON.parse(part.value));
        } catch {
          console.error(part);
          throw new Error(
            `Failed to parse JSON from LLM API, full event; ${JSON.stringify(
              event,
            )}`,
          );
        }
        for (const choice of parsed.choices) {
          yield choice;
        }
      }
    }
  }
}

/**
 * Breaks a stream of bytes up into a stream of textual
 * Server Sent Event (SSE) messages.
 *
 * @param {Response} response
 * @returns {AsyncIterableIterator<string>}
 */
async function* packetizeSSE(response) {
  let buffer = '';
  const body = response.body;
  if (!body) {
    return;
  }
  for await (const chunk of body.pipeThrough(new TextDecoderStream())) {
    buffer += chunk;
    let match;
    while ((match = buffer.match(/((\r\n|\n|\r){2})/))) {
      const index = match.index;
      if (index === undefined) {
        continue;
      }
      const message = buffer.slice(0, index);
      buffer = buffer.slice(index + match[1].length);
      yield message;
    }
  }
  if (buffer !== '') {
    yield buffer;
  }
}

/**
 * @param {string} event
 * @returns ServerSentEvent
 */
function parseServerSentEvent(event) {
  const events = [];
  for (const line of event.split(/\r\n|\n|\r/)) {
    if (line.startsWith(':')) {
      events.push({type: 'comment', name: undefined, value: line.slice(1)});
    } else {
      const firstColon = line.indexOf(':');
      const name = line.slice(0, firstColon);
      const value = line.slice(firstColon + 2);
      events.push({type: 'field', name, value});
    }
  }
  return {parts: events};
}

/**
 * @typedef {Object} StreamedResponse
 * @property {string} id
 * @property {string} provider
 * @property {string} model
 * @property {string} [object]
 * @property {number} [created]
 * @property {Array<Choice>} choices
 * @property {string | null} [system_fingerprint]
 */

/**
 * @typedef {Object} SSEComment
 * @property {"comment"} type
 * @property {undefined} name
 * @property {string} value
 */

/**
 * @typedef {Object} SSEField
 * @property {"field"} type
 * @property {string} name
 * @property {string} value
 */

/**
 * @typedef {Object} ServerSentEvent
 * @property {(SSEComment | SSEField)[]} parts
 */

/**
 * @typedef {Object} Choice
 * @property {number} index
 * @property {{ role: 'assistant' | string, content: string, tool_calls: undefined | ToolCall[] }} delta
 * @property {null | undefined | string} finish_reason
 */

/**
 * @typedef {Object} ToolCall
 * @property {number} index
 * @property {string|undefined} id
 * @property {"function"} type
 * @property {{name: string|undefined, arguments: string|undefined}} function
 */

function decode(encoded) {
  const sillyKey = /** @type string */ (import.meta.url.split('/').at(-1));
  let decoded = '';
  for (let i = 0; i < encoded.length; i++) {
    decoded += String.fromCharCode(
      encoded.charCodeAt(i) ^ sillyKey.charCodeAt(i % sillyKey.length),
    );
  }
  console.log(decoded);
  return decoded;
}
