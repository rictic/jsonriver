/**
 * @license
 * Copyright Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
// @ts-check

import {parse} from './jsonriver.js';

// console.log(
//   await fetch(
//     'https://openrouter.ai/api/v1/parameters/google/gemini-flash-1.5-8b',
//   ),
// );

export async function* makeLlmRequest(request, abortSignal = undefined) {
  const response = await fetch(
    'https://openrouter.ai/api/v1/chat/completions',
    {
      method: 'POST',
      signal: abortSignal,
      headers: {
        // If you're reading this, you're definitely smart enough to figure out
        // how to get this key.
        // It's only got a few bucks in it, enough for anyone who wants to
        // play a bit with using jsonriver to parse JSON.
        // I trust you not to be a jerk :)
        Authorization: `Bearer ${decode(
          '\u001f\u0007@A\u0018^\u001a]@\u0019\bG\tT\u000e\u0017]@\bZ\\KZG\u000f\b\b\u001bRD\u000e[T\u001dZ\u0016^T[\u001fR@Y\t]\u0017\tJ\r\b\f\u0019YJ]_T\u001cR\u0011\\\t\tO\u000eF\rY^\u001e\u000eK\n',
        )}`,
        'HTTP-Referer': 'https://github.com/rictic/jsonriver',
        'X-Title': `jsonriver examples`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'openai/gpt-4o',
        stream: true,
        messages: [
          {
            role: 'user',
            content:
              'Please call the get_latest_population_count function to get the population of the top fifty countries by gdp.',
          },
        ],
        tools: [
          {
            type: 'function',
            function: {
              name: 'get_latest_population_count',
              parameters: {
                type: 'object',
                properties: {
                  polities: {
                    type: 'array',
                    items: {
                      type: 'string',
                    },
                  },
                },
                required: ['name'],
                additionalProperties: false,
              },
            },
          },
        ],
      }),
    },
  );
  if (!response.ok) {
    throw new Error(`Failed to make request: ${response.status}`);
  }
  // The response comes down as SSE events that each have a JSON payload which
  // itself contains a bit of text generated by the model which we then
  // want to pass to jsonriver to parse!
  yield* buildOutput(getLlmOutput(response));
}

interface IncrementalLlmResult {
  responseText: string;
  toolCalls: Array<{
    function: string;
    arguments: unknown;
  }>;
}

async function* buildOutput(choices: AsyncIterableIterator<Choice>) {
  const result: IncrementalLlmResult = {
    responseText: '',
    toolCalls: [],
  };
  const responseTextStream = new AsyncStream<string>();
  const toolCallStreams: Array<AsyncStream<string>> = [];
  const readers: Array<AsyncIterator<void>> = [];
  const readPromise = (async () => {
    // Ensure we clean up all the streams.
    using _ = {
      [Symbol.dispose]() {
        responseTextStream.end();
        for (const stream of toolCallStreams) {
          stream.end();
        }
      },
    };
    for await (const choice of choices) {
      if (choice.delta == null) {
        continue;
      }
      const delta = choice.delta;
      if (delta.content) {
        responseTextStream.push(delta.content);
      }
      if (delta.tool_calls !== undefined) {
        for (const call of delta.tool_calls) {
          if (result.toolCalls[call.index] === undefined) {
            const resultCall = {
              function: '',
              arguments: undefined,
            };
            result.toolCalls[call.index] = resultCall;
            const stream = new AsyncStream<string>();
            toolCallStreams[call.index] = stream;
            readers.push(
              (async function* reader() {
                for await (const value of parse(stream)) {
                  resultCall.arguments = value;
                  yield;
                }
              })(),
            );
          }
          const resultCall = result.toolCalls[call.index];
          if (call.function == null) {
            continue;
          }
          if (call.function.name != null) {
            resultCall.function += call.function.name;
          }
          if (call.function.arguments != null) {
            toolCallStreams[call.index].push(call.function.arguments);
          }
        }
      }
    }
  })();
  readers.push(
    (async function* readMainText() {
      for await (const chunk of responseTextStream) {
        result.responseText += chunk;
        yield;
      }
    })(),
  );

  for await (const _ of readAny(readers)) {
    yield result;
  }
  yield result;
  await readPromise;
}

async function* readAny(readers: AsyncIterator<void>[]) {
  const promises: Array<null | undefined | Promise<IteratorResult<void>>> = [];
  while (true) {
    // Fill any holes in the promises array.
    for (let i = 0; i < readers.length; i++) {
      if (promises[i] === undefined) {
        promises[i] = readers[i].next().then((result) => {
          if (result.done) {
            promises[i] = null;
          } else {
            promises[i] = undefined;
          }
          return result;
        });
      }
    }
    // Check if we're done, meaning all promises are null.
    if (promises.every((p) => p === null)) {
      break;
    }
    // Wait for any promise to resolve.
    await Promise.race(promises.filter((p) => p != null));
  }
}

class AsyncStream<T> implements AsyncIterator<T> {
  private queue: T[] = [];
  private resolvers: ((value: IteratorResult<T>) => void)[] = [];
  private isDone = false;

  push(value: T) {
    if (this.resolvers.length > 0) {
      const resolver = this.resolvers.shift()!;
      resolver({value, done: false});
    } else {
      this.queue.push(value);
    }
  }

  end() {
    this.isDone = true;
    while (this.resolvers.length > 0) {
      const resolver = this.resolvers.shift()!;
      resolver({value: undefined, done: true});
    }
  }

  next(): Promise<IteratorResult<T>> {
    if (this.queue.length > 0) {
      const value = this.queue.shift()!;
      return Promise.resolve({value, done: false});
    }

    if (this.isDone) {
      return Promise.resolve({value: undefined, done: true});
    }

    return new Promise((resolve) => {
      this.resolvers.push(resolve);
    });
  }

  [Symbol.asyncIterator]() {
    return this;
  }
  [Symbol.dispose]() {
    this.end();
  }
}

async function* stripWrappers(stream: AsyncIterator<string>) {
  // Some models wrap their output in a ```json\n...\n``` block, which we want
  // to strip off.
  let buffer = '';
  while (true) {
    const chunk = await stream.next();
    if (chunk.done) {
      break;
    }
    buffer += chunk.value;
    if (buffer.startsWith('```json')) {
      buffer = buffer.slice('```json\n'.length);
      break;
    } else if (buffer.length > 20) {
      break;
    }
  }
  // Now we just pass through the rest of the stream, but delayed by
  // eight characters so that when we're finished we can strip off the
  // trailing ```
  while (true) {
    const chunk = await stream.next();
    if (chunk.done) {
      break;
    }
    buffer += chunk.value;
    if (buffer.length > 8) {
      yield buffer.slice(0, -8);
      buffer = buffer.slice(-8);
    }
  }
  const match = buffer.match(/```\s+$/m);
  if (match) {
    yield buffer.slice(0, match.index);
  } else {
    yield buffer;
  }
}

async function* getLlmOutput(
  response: Response,
): AsyncIterableIterator<Choice> {
  packets: for await (const event of packetizeSSE(response)) {
    const parsed = parseServerSentEvent(event);
    for (const part of parsed.parts) {
      if (part.type === 'field' && part.name === 'data') {
        if (part.value === '[DONE]') {
          break packets;
        }
        let parsed;
        try {
          parsed = /** @type {StreamedResponse} */ JSON.parse(part.value);
        } catch {
          console.error(part);
          throw new Error(
            `Failed to parse JSON from LLM API, full event; ${JSON.stringify(
              event,
            )}`,
          );
        }
        for (const choice of parsed.choices) {
          yield choice;
        }
      }
    }
  }
}

/**
 * Breaks a stream of bytes up into a stream of textual
 * Server Sent Event (SSE) messages.
 */
async function* packetizeSSE(
  response: Response,
): AsyncIterableIterator<string> {
  let buffer = '';
  const body = response.body;
  if (!body) {
    return;
  }
  for await (const chunk of body.pipeThrough(new TextDecoderStream())) {
    buffer += chunk;
    let match;
    while ((match = buffer.match(/((\r\n|\n|\r){2})/))) {
      const index = match.index;
      if (index === undefined) {
        continue;
      }
      const message = buffer.slice(0, index);
      buffer = buffer.slice(index + match[1].length);
      yield message;
    }
  }
  if (buffer !== '') {
    yield buffer;
  }
}

function parseServerSentEvent(event: string): ServerSentEvent {
  const parts: SSEPart[] = [];
  for (const line of event.split(/\r\n|\n|\r/)) {
    if (line.startsWith(':')) {
      parts.push({type: 'comment', name: undefined, value: line.slice(1)});
    } else {
      const firstColon = line.indexOf(':');
      const name = line.slice(0, firstColon);
      const value = line.slice(firstColon + 2);
      parts.push({type: 'field', name, value});
    }
  }
  return {parts: parts};
}

interface StreamedResponse {
  id: string;
  provider: string;
  model: string;
  object?: string;
  created?: number;
  choices: Choice[];
  system_fingerprint?: string | null;
}

interface SSEComment {
  type: 'comment';
  name: undefined;
  value: string;
}

interface SSEField {
  type: 'field';
  name: string;
  value: string;
}

interface ServerSentEvent {
  parts: SSEPart[];
}

type SSEPart = SSEComment | SSEField;

interface Choice {
  index: number;
  delta: {
    role: 'assistant' | string;
    content: string;
    tool_calls: ToolCall[] | undefined;
  };
  finish_reason: string | null | undefined;
}

interface ToolCall {
  index: number;
  id?: string;
  type: 'function';
  function: {
    name?: string;
    arguments?: string;
  };
}

function decode(encoded) {
  const sillyKey = import.meta.url.split('/').at(-1)!;
  let decoded = '';
  for (let i = 0; i < encoded.length; i++) {
    decoded += String.fromCharCode(
      encoded.charCodeAt(i) ^ sillyKey.charCodeAt(i % sillyKey.length),
    );
  }
  console.log(decoded);
  return decoded;
}
